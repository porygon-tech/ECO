# -*- coding: utf-8 -*-
"""The_Effect_of_Polygenic_Adaptation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/porygon-tech/ECO/blob/main/demos/The_Effect_of_Polygenic_Adaptation.ipynb
"""

#@title imports and definitions
from scipy.special import comb  
import numpy as np
import matplotlib.pyplot as plt
#from scipy.optimize import curve_fit

#---for obj handling---
from os import chdir, listdir, environ
from pathlib import Path
import pickle5
import bz2
chdir(environ['HOME'] + '/LAB/ECO') #this line is for Spyder IDE only
root = Path(".")
obj_path = root / 'data/obj'
img_path = root / 'gallery/timeseries'

#---for animations---
from matplotlib import rc
rc('animation', html='jshtml')
import matplotlib.animation as animation
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.colors import LogNorm
import copy

#%%
import matplotlib.colors

def blend(image1, image2, cmap1, cmap2,norm=None):
    if norm:
        a = norm(cmap1(image1).sum(2))
        b = norm(cmap2(image2).sum(2))
    else:
        a = cmap1(image1)
        b = cmap2(image2)

    screen = 1 - (1 - a) * (1 - b)
    return screen


def rescale(arr: np.ndarray, vmin=0,vmax=1):
    re = (arr - vmin) / (vmax - vmin)
    return re
#%% 


def quantilebands(mat,width=0.25):
    t=np.arange(mat.shape[1])
    return np.append(t,np.flip(t)), np.append((mat.cumsum(0)>=.5-width).argmax(0),np.flip((mat.cumsum(0)>=.5+width).argmax(0)))


def plotQuantilebands(ax, mat, widths, alpha=1, color='green'):
    for width in widths:
        x,y=quantilebands(mat,width); ax.fill(x,y,alpha=alpha/len(widths)*np.sqrt(.5-width),color=color) #alpha*(.5-width)

def expnorm(x, a=1):
    return 1-np.exp(-a*x)
#showlist(expnorm(np.linspace(0, 1, 200),5))
def cNorm(x, k=1):
    return (k**2*x) / (1 + (-1 + k**2)*x)

#%%

'''
cmapgrn = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "cyan"]) #seagreen also
cmapred = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "red"])

a=cmapred(mat1)
b=cmapgrn(mat2)
norm=np.linspace(0,1,100)
cmapgrn = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "cyan"])
screen = 1 - (1 - a) * (1 - b)
a.shape
'''
#%%
def bindist(n,k,p=0.5):
    return comb(n,k)*p**k*(1-p)**(n-k)

def showfunc(f,xlim=(-5,5),definition=100, **kwargs):
            x= np.linspace(xlim[0],xlim[1],definition)
            fig = plt.figure(); ax = fig.add_subplot(111)
            ax.plot(x,f(x,**kwargs))
            plt.show()

def showlist(l, distbins=False):
            fig = plt.figure(); ax = fig.add_subplot(111)
            ax.plot(np.arange(len(l)),list(l))
            plt.show()

def showdata(mat, color='magma', symmetry=False):
    mat = np.copy(mat)
    if symmetry:
        top = np.max([np.abs(np.nanmax(mat)),np.abs(np.nanmin(mat))])
        plt.imshow(mat.astype('float32'), interpolation='none', cmap='seismic',vmax=top,vmin=-top)
    else:
        plt.imshow(mat.astype('float32'), interpolation='none', cmap=color)
    plt.colorbar()
    plt.show()

def augment(x,a=10,b=5):
    return 1-np.exp**(-b*x)

#%%
n=100
nstates=n+1
filename='oc_tensor_' + str(n) + '.obj'
with bz2.BZ2File(obj_path / filename, 'rb') as f:
	oc_tensor = pickle5.load(f)


#%%
#@title POPULATION INITIALISATION
#------------------------

ntimesteps = 200
#%%
skw=.70#np.random.rand()
v = np.zeros((ntimesteps, nstates,1))
for i in range(nstates):
    v[0,i] = bindist(n,i,skw)

#%%
def f(i):
    #return 1+n-i
    #return 2**(-i/2)
    #return n**2-i**2
    alpha=0.001; m=1/4*n
    #return (phi*(-1/2*(theta-i)**2)-np.min((phi*(-1/2*(theta-n)**2),phi*theta)))
    return np.exp(-alpha*(i-m)**2)

l = np.zeros((nstates,1))
for i in range(nstates):
    l[i] = f(i)

#------------------------
#showlist(v[0])
showlist(l)

#%%
#STANDARD RUN
phi=0.04
z = np.zeros((ntimesteps,1))
z[0]=(np.arange(nstates)*v[0].T).sum() #mean
theta=np.where(l==max(l))[0][0] #max of f (should have only one)


for t in range(1,ntimesteps):
    w = v[t-1]*l
    v[t] = ((w.T @ oc_tensor @ w) / w.sum()**2)[:,0]
    z[t]=z[t-1]+phi*(theta-z[t-1])


fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
#div = make_axes_locatable(ax)
#cax = div.append_axes('right', '5%', '5%')
#cax = plt.axes([0.85, 0.1, 0.075, 0.8]
imsh = ax.imshow(v[...,0].T, interpolation='none', cmap='magma')
ax.plot(np.arange(ntimesteps),(v[...,0]*np.arange(nstates)).mean(1)*nstates,color='yellow')
ax.plot(np.arange(ntimesteps),z,color='cyan')
fig.canvas.toolbar_visible = False
fig.canvas.header_visible = False
fig.canvas.resizable = True
fig.colorbar(imsh)
plt.show()

#=====================================================================================================
#=====================================================================================================
#%%
#@title  AFTER A CHANGE IN ENVIRONMENTAL SELECTION
v2 = np.zeros((ntimesteps, nstates,1))
l2 = np.flip(l)

#showlist(v[-1])
v2[0] = v[-1]
for t in range(1,ntimesteps):
    w2 = v2[t-1]*l2
    v2[t] = ((w2.T @ oc_tensor @ w2) / w2.sum()**2)[:,0]

#showdata(np.append(v,v2,axis=0)[...,0])
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
imsh = ax.imshow(np.append(v,v2,axis=0)[...,0], interpolation='none', cmap='magma')
fig.canvas.toolbar_visible = False
fig.canvas.header_visible = False
fig.canvas.resizable = True
fig.colorbar(imsh)
plt.show()





"""# New Section"""

s1=v[np.random.randint(ntimesteps)]
s2=v[np.random.randint(ntimesteps)]

skw_1, skw_2 = np.random.rand(2)

for i in range(nstates):
    s1[i] = bindist(n,i,skw_1)
    s2[i] = bindist(n,i,skw_2)

'''
fig = plt.figure(); ax = fig.add_subplot(111)
ax.plot(np.arange(nstates),s1)
ax.plot(np.arange(nstates),s2)
plt.show()
'''
m_comb_probs=s1@s2.T
showdata(m_comb_probs)
#%% 

v_s1 = np.zeros((ntimesteps, nstates,1))
v_s2 = np.zeros((ntimesteps, nstates,1))
l_s1 = np.zeros((ntimesteps, nstates,1))
l_s2 = np.zeros((ntimesteps, nstates,1))

l_s1[0] = s2
l_s2[0] = s1

v_s1[0] = s1
v_s2[0] = s2

for t in range(1,ntimesteps):
    
    w_s1 = v_s1[t-1]*l_s1[t-1]
    w_s2 = v_s2[t-1]*l_s2[t-1]
    v_s1[t] = ((w_s1.T @ oc_tensor @ w_s1) / w_s1.sum()**2)[:,0]
    v_s2[t] = ((w_s2.T @ oc_tensor @ w_s2) / w_s2.sum()**2)[:,0]
    #l_s1[t] = np.max(v_s2[t])-v_s2[t]
    #l_s2[t] = np.max(v_s1[t])-v_s1[t]
    l_s1[t] = 1/(1+100*v_s2[t])#*1/(1+1000*v_s1[t])
    #l_s2[t] = 1/(1+10000*v_s1[t])#*1/(1+10000*v_s2[t])
    l_s2[t] = v_s1[t]*1/(1+100*v_s2[t])

#%%
showdata(v_s1[...,0])
showdata(v_s2[...,0])


my_cmap = copy.copy(plt.cm.get_cmap('magma')) # copy the default cmap
my_cmap.set_bad((0,0,0))

fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
div = make_axes_locatable(ax)
#cax = div.append_axes('right', '5%', '5%')
def frame(t):
    ax.clear()
    #plot=ax.imshow(l_matrix[:,:,w].astype('float32'), interpolation='none', cmap=my_cmap,vmax=1,vmin=10e-20,norm=LogNorm(vmin=0, vmax=1)) #
    ax.set_ylim(0,0.1)
    plot=ax.bar(np.arange(nstates),v_s1[t,:,0],width=1,alpha=0.5)
    plot+=ax.bar(np.arange(nstates),v_s2[t,:,0],width=1,alpha=0.5)
    #fig.colorbar(plot,ax=ax,cax=cax)
    return plot

anim = animation.FuncAnimation(fig, frame, frames=200, blit=False, repeat=True)

anim

fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
div = make_axes_locatable(ax)
cax = div.append_axes('right', '5%', '5%')
def frame(t):
    ax.clear()
    plot=ax.imshow(v_s1[t]@v_s2[t].T, interpolation='none', cmap='magma',vmax=0.005,vmin=0) #
    fig.colorbar(plot,ax=ax,cax=cax)
    return plot

anim = animation.FuncAnimation(fig, frame, frames=100, blit=False, repeat=True)

anim

s1=np.zeros((nstates,1))
s2=np.zeros((nstates,1))

skw_1, skw_2 = np.random.rand(2)

for i in range(nstates):
    s1[i] = bindist(n,i,skw_1)
    s2[i] = bindist(n,i,skw_2)

'''
fig = plt.figure(); ax = fig.add_subplot(111)
ax.plot(np.arange(nstates),s1)
ax.plot(np.arange(nstates),s2)
plt.show()
'''
m_comb_probs=s1@s2.T
showdata(m_comb_probs)
#%%
skw_1, skw_2 = np.random.rand(2)

for i in range(nstates):
    s1[i] = bindist(n,i,skw_1)
    s2[i] = bindist(n,i,skw_2)


v_s1 = np.zeros((ntimesteps, nstates,1))
v_s2 = np.zeros((ntimesteps, nstates,1))
l_s1 = np.zeros((ntimesteps, nstates,1))
l_s2 = np.zeros((ntimesteps, nstates,1))

l_s1[0] = s1
l_s2[0] = s2

v_s1[0] = s1
v_s2[0] = s2

for t in range(1,ntimesteps):
    
    w_s1 = v_s1[t-1]*l_s1[t-1]
    w_s2 = v_s2[t-1]*l_s2[t-1]
    v_s1[t] = ((w_s1.T @ oc_tensor @ w_s1) / w_s1.sum()**2)[:,0]
    v_s2[t] = ((w_s2.T @ oc_tensor @ w_s2) / w_s2.sum()**2)[:,0]
    #l_s1[t] = np.max(v_s2[t])-v_s2[t]
    #l_s2[t] = np.max(v_s1[t])-v_s1[t]
    l_s1[t] = 1/(1+200*v_s2[t])*1/(1+600*v_s1[t])
    #l_s2[t] = 1/(1+10000*v_s1[t])#*1/(1+10000*v_s2[t])
    #l_s2[t] = v_s1[t]*1/(1-200*(v_s2[t]-1)) # positive freq-dependent sel
    l_s2[t] = v_s1[t]*1/(1+120*v_s1[t]) # negative freq-dependent sel

#%%
'''
showdata(v_s1[...,0])
showdata(v_s2[...,0])

fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
div = make_axes_locatable(ax)
#cax = div.append_axes('right', '5%', '5%')
def frame(t):
    ax.clear()
    #plot=ax.imshow(l_matrix[:,:,w].astype('float32'), interpolation='none', cmap=my_cmap,vmax=1,vmin=10e-20,norm=LogNorm(vmin=0, vmax=1)) #
    ax.set_ylim(0,0.1)
    plot=ax.bar(np.arange(nstates),v_s1[t,:,0],width=1,alpha=0.5)
    plot+=ax.bar(np.arange(nstates),v_s2[t,:,0],width=1,alpha=0.5)
    #fig.colorbar(plot,ax=ax,cax=cax)
    return plot

anim = animation.FuncAnimation(fig, frame, frames=100, blit=False, repeat=True)

anim

'''
#=====================================================================================================
#=====================================================================================================
#%%With soft interaction probabilities


import matplotlib.colors as colors


def pM (zdiffs, alpha=50):
    return np.exp(-alpha*(zdiffs)**2)

def pB (zdiffs, alpha=50):
    return 1/(1+np.exp(-alpha*(zdiffs)))

def convpM(values,nstates,alpha):
  c = np.zeros((nstates))
  for i in range(nstates):
    c = c + pM(np.arange(nstates)-i, alpha)*values[i]
  return c

def convpB(values,nstates,alpha):
  c = np.zeros((nstates))
  for i in range(nstates):
    c = c + pB(np.arange(nstates)-i, alpha)*values[i]
  return c

#%%
s1=np.zeros((nstates,1))
s2=np.zeros((nstates,1))

skw_1, skw_2 = np.random.rand(2)

for i in range(nstates):
    s1[i] = bindist(n,i,skw_1)
    s2[i] = bindist(n,i,skw_2)

'''
alpha = 0.05

pM_s1=convpM(s1,nstates,alpha)
pB_s1=convpB(s1,nstates,alpha)

showlist(s1)
showlist(pM_s1)
showlist(pB_s1)
'''

#%%

alpha=0.1
a=20
b=1

v_s1 = np.zeros((ntimesteps, nstates,1))
v_s2 = np.zeros((ntimesteps, nstates,1))
l_s1 = np.zeros((ntimesteps, nstates,1))
l_s2 = np.zeros((ntimesteps, nstates,1))

l_s1[0] = s1
l_s2[0] = s2

v_s1[0] = s1
v_s2[0] = s2

for t in range(1,ntimesteps):
    w_s1 = v_s1[t-1]*l_s1[t-1]
    w_s2 = v_s2[t-1]*l_s2[t-1]
    v_s1[t] = ((w_s1.T @ oc_tensor @ w_s1) / w_s1.sum()**2)[:,0]
    v_s2[t] = ((w_s2.T @ oc_tensor @ w_s2) / w_s2.sum()**2)[:,0]
    pM_s1=convpM(v_s1[t],nstates,alpha)[:,np.newaxis]
    pM_s2=convpM(v_s2[t],nstates,alpha)[:,np.newaxis]
    l_s1[t] = 1/(1+a*pM_s2) #* 1/(1+10*pM_s1)
    #l_s2[t] = 1/(1+10000*v_s1[t])#*1/(1+10000*v_s2[t])
    #l_s2[t] = v_s1[t]*1/(1-200*(v_s2[t]-1)) # positive freq-dependent sel
    l_s2[t] = pM_s1*b #* 1/(1+10*pM_s2) # negative freq-dependent sel


#%% ADDITIVE PLOT


mat1= (v_s1[...,0].T)
mat2= (v_s2[...,0].T)

temp_max=np.max((mat1,mat2))
temp_min=np.min((mat1,mat2))

G_r = rescale(mat1, temp_min,temp_max) #clip?
R_r = rescale(mat2, temp_min,temp_max)

cmapgrn = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "cyan"]) #seagreen also
cmapred = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "red"])

blended1=blend(image1 = G_r,
               image2 = R_r,
               cmap1 = cmapgrn,
               cmap2 = cmapred)

temp_g = 1.2
blended2=blend(image1 = cNorm(G_r,temp_g),
               image2 = cNorm(R_r,temp_g),
               cmap1 = cmapgrn,
               cmap2 = cmapred)


fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
pos = ax.imshow(blended2,interpolation='None')
fig.suptitle(r'$\alpha=$'+str(alpha)+', a='+str(a)+', b='+str(b),fontweight='bold',y=0.85)
ax.set_ylabel('Trait value')
ax.set_xlabel('Time (generations)')
plt.tight_layout()
plt.show()
#%%
fig.savefig(img_path / 'test.pdf',format='pdf')

#%%
#showdata(v_s1[...,0].T)
#showdata(v_s2[...,0].T)

palette = 'magma'
temp_g=1./1.5
mat1= (v_s1[...,0].T)
mat2= (v_s2[...,0].T)
temp_max=np.max((v_s1,v_s2))
temp_min=np.min((v_s1,v_s2))


fig = plt.figure(figsize=(8,6)); 
ax1 = fig.add_subplot(211)
ax2 = fig.add_subplot(212)
pos = ax1.imshow(mat1, interpolation='none', cmap=palette,norm=colors.PowerNorm(gamma=temp_g,vmin=temp_min,vmax=temp_max,))
ax2.imshow(      mat2, interpolation='none', cmap=palette,norm=colors.PowerNorm(gamma=temp_g,vmin=temp_min,vmax=temp_max,))
fig.colorbar(pos, ax=[ax1,ax2])
#fig.suptitle('Time evolution of coevolving trait probability mass functions',fontweight='bold',y=0.95)
fig.suptitle(r'$\alpha=$'+str(alpha)+', a='+str(a)+', b='+str(b),fontweight='bold',y=0.95)
ax1.set_ylabel('Species X')
ax2.set_ylabel('Species Y')
fig.text(0.5, 0.02, 'Time (generations)', ha='center',size=12)
fig.text(.11, 0.5, 'Trait value',       va='center', rotation='vertical',size=12)
plt.show()


















#%% THREE SPECIES
skw_1, skw_2, skw_3 = np.random.rand(3)

s1=np.zeros((nstates,1))
s2=np.zeros((nstates,1))
s3=np.zeros((nstates,1))

for i in range(nstates):
    s1[i] = bindist(n,i,skw_1)
    s2[i] = bindist(n,i,skw_2)
    s3[i] = bindist(n,i,skw_3)

#%%
alpha=0.04
ntimesteps=4000
a=4.9
a12=a
a13=a
b=1
v_s1 = np.zeros((ntimesteps, nstates,1))
v_s2 = np.zeros((ntimesteps, nstates,1))
v_s3 = np.zeros((ntimesteps, nstates,1))
l_s1 = np.zeros((ntimesteps, nstates,1))
l_s2 = np.zeros((ntimesteps, nstates,1))
l_s3 = np.zeros((ntimesteps, nstates,1))

l_s1[0] = s1
l_s2[0] = s2
l_s3[0] = s3

v_s1[0] = s1
v_s2[0] = s2
v_s3[0] = s3

for t in range(1,ntimesteps):
    w_s1 = v_s1[t-1]*l_s1[t-1]
    w_s2 = v_s2[t-1]*l_s2[t-1]
    w_s3 = v_s3[t-1]*l_s3[t-1]
    v_s1[t] = ((w_s1.T @ oc_tensor @ w_s1) / w_s1.sum()**2)[:,0]
    v_s2[t] = ((w_s2.T @ oc_tensor @ w_s2) / w_s2.sum()**2)[:,0]
    v_s3[t] = ((w_s3.T @ oc_tensor @ w_s3) / w_s3.sum()**2)[:,0]
    pM_s1=convpM(v_s1[t],nstates,alpha)[:,np.newaxis]
    pM_s2=convpM(v_s2[t],nstates,alpha)[:,np.newaxis]
    pM_s3=convpM(v_s3[t],nstates,alpha)[:,np.newaxis]
    
    l_s1[t] = pM_s2*b+pM_s3*b 
    l_s2[t] = 1/(1+a12*pM_s1) 
    l_s3[t] = 1/(1+a13*pM_s1) 


'''
l_s1[t] = pM_s2*b 
l_s2[t] = pM_s3*b /(1+a*pM_s1) 
l_s3[t] =       1 /(1+a*pM_s2) 
'''

mat1= (v_s1[...,0].T)
mat2= (v_s2[...,0].T)
mat3= (v_s3[...,0].T)

dataset_temp = (tuple((vrange*mat1*nstates).mean(0)),tuple((vrange*mat2*nstates).mean(0)),tuple((vrange*mat3*nstates).mean(0)))

#%% BAND PLOT
vrange=np.arange(nstates)[:,np.newaxis]
t=np.arange(ntimesteps)
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
#ax.imshow(mat1,interpolation='None')

ax.plot(t, (vrange*mat1*nstates).mean(0), color='red'); plotQuantilebands(ax, mat1, [.25,.40,.49],color='red')

ax.plot(t,(vrange*mat2*nstates).mean(0),color='green'); plotQuantilebands(ax, mat2, [.25,.40,.49],color='green')

ax.plot(t,(vrange*mat3*nstates).mean(0),color='blue');  plotQuantilebands(ax, mat3, [.25,.40,.49],color='blue')
#ax.plot(t, (mat1.cumsum(0)>=.5).argmax(0))

fig.suptitle(r'$\alpha=$'+str(alpha)+r'$, a_{12}=$'+str(a12)+r'$, a_{13}=$'+str(a13)+', b='+str(b))
ax.set_ylabel('Trait value')
ax.set_xlabel('Time (generations)')
plt.tight_layout()
plt.show()


#%%
#fig.savefig(img_path / 'bands_nonchaos.pdf',format='pdf')

#%%

#%% SAVE
filename='trajectory_alpha'+str(alpha)+'_a'+str(a)+'_t' + str(ntimesteps) +'.obj'
with bz2.BZ2File(obj_path / 'trajectories' / filename, 'wb') as f:
    pickle5.dump(dataset_temp, f)
#%% LOAD
#filename='trajectory_alpha0.04_a5_t8000.obj'
#filename=trajectory_alpha0.04_a4.9_t4000.obj
listdir(obj_path / 'trajectories' )
filename=np.random.choice(listdir(obj_path / 'trajectories' )); print('imported ' + filename)
with bz2.BZ2File(obj_path / 'trajectories' / filename, 'rb') as f:
	dataset_temp = pickle5.load(f)

#%%
fig = plt.figure(figsize=(12,16))
ax = fig.add_subplot(111, projection='3d')
ax.plot(dataset_temp[0],dataset_temp[1],dataset_temp[2],linewidth=.5)
ax.set_xlabel('$S_1$')
ax.set_ylabel('$S_2$')
ax.set_zlabel(r'$S_3$')
ax.xaxis.set_rotate_label(False) 
ax.yaxis.set_rotate_label(False) 
ax.zaxis.set_rotate_label(False) 
plt.show()


#%% Fast fourier transform

fig = plt.figure(figsize=(8,6));ax = fig.add_subplot(111)
for i in range(len(dataset_temp)):
    FFT =np.fft.fft(dataset_temp[i])
    new_N=int(len(FFT)/2) 
    new_X = np.linspace(10**-12, f_nat/2, new_N, endpoint=True)
    new_Xph=1.0/(new_X)
    FFT_abs=np.abs(FFT)
    ax.plot(new_Xph,2*FFT_abs[0:int(len(FFT)/2.)]/len(new_Xph),alpha=1,linewidth=1)
    
ax.set_xlabel('Period ($h$)',fontsize=10)
ax.set_ylabel('Amplitude',fontsize=10)
fig.suptitle('(Fast) Fourier Transform Method Algorithm',fontsize=20)
ax.grid(True)
ax.set_xlim(0,600)
ax.set_ylim(0,60)
plt.show()

#%%
#showlist(dataset_temp[i])
#from scipy.signal import find_peaks
#from scipy.fft import fft, fftfreq


#%% Fast fourier transform
f_nat=1
FFT =np.fft.fft(dataset_temp[1])
new_N=int(len(FFT)/2) 
new_X = np.linspace(10**-12, f_nat/2, new_N, endpoint=True)
new_Xph=1.0/(new_X)
FFT_abs=np.abs(FFT)


height_threshold=10
# peaks_index contains the indices in x that correspond to peaks:
peaks_index, properties = find_peaks(FFT_abs, height=height_threshold*new_N/2)
freq = np.fft.fftfreq(len(dataset_temp[0]))

fig = plt.figure(figsize=(8,6));ax = fig.add_subplot(111)
ax.plot(new_Xph,2*FFT_abs[0:new_N]/len(new_Xph),color='black')
ax.scatter(1/freq[peaks_index],properties['peak_heights']*2/new_N)
ax.set_xlabel('Period ($h$)',fontsize=10)
ax.set_ylabel('Amplitude',fontsize=10)
fig.suptitle('(Fast) Fourier Transform Method Algorithm',fontsize=20)
ax.grid(True)
ax.set_xlim(0,600)
ax.set_ylim(0,60)
plt.show()



#%%
def get_cmap(n, name='hsv'):
    '''Returns a function that maps each index in 0, 1, ..., n-1 to a distinct 
    RGB color; the keyword argument name must be a standard mpl colormap name.'''
    return plt.cm.get_cmap(name, n+1)


#%% freq bars

periods=1/freq[peaks_index]
periods=periods[:int(len(periods)/2)]


bands_x=(periods[:,np.newaxis]*np.arange(100)[np.newaxis,:])

colors=get_cmap(bands_x.shape[0])

fig = plt.figure(figsize=(8,6));ax = fig.add_subplot(111)
#ax.plot(np.arange(len(dataset_temp[0])),dataset_temp[0])
ax.plot(np.arange(len(dataset_temp[0])),dataset_temp[1])
#ax.plot(np.arange(len(dataset_temp[0])),dataset_temp[2])

for i_freq in range(bands_x.shape[0]):
    for band in range(bands_x.shape[1]):
        ax.plot((bands_x[i_freq,band],bands_x[i_freq,band]),(0,nstates),color=colors(i_freq),alpha=0.5)
ax.set_xlim(10,1000)
plt.show()



#%% ADDITIVE PLOT


temp_max=np.max((mat1,mat2,mat3))
temp_min=np.min((mat1,mat2,mat3))

R_r = rescale(mat1, temp_min,temp_max) #clip?
G_r = rescale(mat2, temp_min,temp_max)
B_r = rescale(mat3, temp_min,temp_max)

cmapgrn = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "green"]) #seagreen also
cmapred = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "red"])
cmapblu = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "blue"])

blended = 1 - (1 - cmapred(R_r)) * (1 - cmapgrn(G_r)) * (1 - cmapblu(B_r))

temp_g = 1.1
blended = cNorm(blended,temp_g)


fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
pos = ax.imshow(blended,interpolation='None')
fig.suptitle(r'$\alpha=$'+str(alpha)+r'$, a_{12}=$'+str(a12)+r'$, a_{13}=$'+str(a13)+', b='+str(b),y=0.75)
ax.set_ylim(0,n)  # decreasing time
ax.set_ylabel('Trait value')
ax.set_xlabel('Time (generations)')

plt.tight_layout()
plt.show()

#%%
fig.savefig(img_path / 'intensity1.pdf',format='pdf')



#%% 

fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
ax.imshow(mat1,interpolation='None')

ax.plot(t, (vrange*mat1*nstates).mean(0), color='red')
x,y=quantilebands(mat1); ax.fill(x,y,alpha=0.2,color='red')
x,y=quantilebands(mat1,0.45); ax.fill(x,y,alpha=0.1,color='red')

fig.suptitle(r'$\alpha=$'+str(alpha)+r'$, a_1=$'+str(a1)+r'$, a_3=$'+str(a3)+', b='+str(b),y=1)
ax.set_ylabel('Trait value')
ax.set_xlabel('Time (generations)')
plt.tight_layout()
plt.show()




#%%
def accumulateExp(x,v=1,L=1):
    return L* (1-np.exp(-v*x))





























#%% THREE SPECIES with abundances
skw_1, skw_2, skw_3 = np.random.rand(3)

s1=np.zeros((nstates,1))
s2=np.zeros((nstates,1))
s3=np.zeros((nstates,1))

for i in range(nstates):
    s1[i] = bindist(n,i,skw_1)
    s2[i] = bindist(n,i,skw_2)
    s3[i] = bindist(n,i,skw_3)

#%% RUN
alpha=0.8
a=10
a1=a
a2=a
a3=a
b=1
#deathRate=0.2
#v_param=1/10
#L_param=20
death_base=0.1
death_resource=1
intra_competition=0.0002
maxoffspr_s1=3
maxoffspr_s2=3
maxoffspr_s3=3
basegrowth=0.1


v_s1 = np.zeros((ntimesteps, nstates,1))
v_s2 = np.zeros((ntimesteps, nstates,1))
v_s3 = np.zeros((ntimesteps, nstates,1))
l_s1 = np.zeros((ntimesteps, nstates,1))
l_s2 = np.zeros((ntimesteps, nstates,1))
l_s3 = np.zeros((ntimesteps, nstates,1))

pM_s1 = np.zeros((ntimesteps, nstates,1))
pM_s2 = np.zeros((ntimesteps, nstates,1))
pM_s3 = np.zeros((ntimesteps, nstates,1))

l_s1[0] = s1
l_s2[0] = s2
l_s3[0] = s3

v_s1[0] = s1
v_s2[0] = s2
v_s3[0] = s3

N_s1 = np.zeros(ntimesteps); N_s1[0] = 500
N_s2 = np.zeros(ntimesteps); N_s2[0] = 1000
N_s3 = np.zeros(ntimesteps); N_s3[0] = 1000

for t in range(1,ntimesteps):
    w_s1 = v_s1[t-1]*l_s1[t-1]
    w_s2 = v_s2[t-1]*l_s2[t-1]
    w_s3 = v_s3[t-1]*l_s3[t-1]
    
    #alpha_s1 = w_s1.sum(); N_s1[t] =  N_s1[t-1] * (1+alpha_s1-deathRate)
    #alpha_s2 = w_s2.sum(); N_s2[t] =  N_s2[t-1] * (1+alpha_s2-deathRate)
    #alpha_s3 = w_s3.sum(); N_s3[t] =  N_s3[t-1] * (1+alpha_s3-deathRate)
    #r_s1 = w_s1.sum(); N_s1[t] = N_s1[t-1] + r_s1 * N_s1[t-1] * (1 - N_s1[t-1]/K) - (death_base + death_resource * N_s1[t-1]/K) * N_s1[t-1] 
    #r_s2 = w_s2.sum(); N_s2[t] = N_s2[t-1] + r_s2 * N_s2[t-1] * (1 - N_s2[t-1]/K) - (death_base + death_resource * N_s2[t-1]/K) * N_s2[t-1] 
    #r_s3 = w_s3.sum(); N_s3[t] = N_s3[t-1] + r_s3 * N_s3[t-1] * (1 - N_s3[t-1]/K) - (death_base + death_resource * N_s3[t-1]/K) * N_s3[t-1] 
    #r_s1 = w_s1.sum(); N_s1[t] = N_s1[t-1] + r_s1 * N_s1[t-1] * (1-intra_competition*r_s1 * N_s1[t-1] ) - death_resource * N_s1[t-1]#**2 
    #r_s2 = w_s2.sum(); N_s2[t] = N_s2[t-1] + r_s2 * N_s2[t-1] * (1-intra_competition*r_s2 * N_s2[t-1] ) - death_resource * N_s2[t-1]#**2 
    #r_s3 = w_s3.sum(); N_s3[t] = N_s3[t-1] + r_s3 * N_s3[t-1] * (1-intra_competition*r_s3 * N_s3[t-1] ) - death_resource * N_s3[t-1]#**2 
    r_s1 = w_s1.sum()+basegrowth; N_s1[t] = N_s1[t-1] * (r_s1) * (1-intra_competition*r_s1 * N_s1[t-1] )
    r_s2 = w_s2.sum()+basegrowth; N_s2[t] = N_s2[t-1] * (r_s2) * (1-intra_competition*r_s2 * N_s2[t-1] )
    r_s3 = w_s3.sum()+basegrowth; N_s3[t] = N_s3[t-1] * (r_s3) * (1-intra_competition*r_s3 * N_s3[t-1] )

    v_s1[t] = ((w_s1.T @ oc_tensor @ w_s1) / w_s1.sum()**2)[:,0]
    v_s2[t] = ((w_s2.T @ oc_tensor @ w_s2) / w_s2.sum()**2)[:,0]
    v_s3[t] = ((w_s3.T @ oc_tensor @ w_s3) / w_s3.sum()**2)[:,0]
    pM_s1[t]=convpM(v_s1[t],nstates,alpha)[:,np.newaxis] #* accumulateExp(N_s1[t-1],v_param,L_param)
    pM_s2[t]=convpM(v_s2[t],nstates,alpha)[:,np.newaxis] #* accumulateExp(N_s2[t-1],v_param,L_param)
    pM_s3[t]=convpM(v_s3[t],nstates,alpha)[:,np.newaxis] #* accumulateExp(N_s3[t-1],v_param,L_param)
    
    pM_s1[t]*=N_s1[t]/pM_s1[t].sum()
    pM_s2[t]*=N_s2[t]/pM_s2[t].sum()
    pM_s3[t]*=N_s3[t]/pM_s3[t].sum()

    #N[t] = N[t-1] + r * N[t-1] * (1 - N[t-1]/K) - (death_base + death_resource * N[t-1]/K) * N[t-1] 
    '''
    l_s1[t] = pM_s2*b+pM_s3*b 
    l_s2[t] = 1/(1+a1*pM_s1) 
    l_s3[t] = 1/(1+a3*pM_s1) 
    '''
    #l_s1[t] = maxoffspr_s1*(1-1/(1+pM_s2[t]*b+pM_s3[t]*b)) 
    l_s2[t] = 1/(1+a12*pM_s1[t]+a12*pM_s3[t]) * maxoffspr_s2             
    #l_s3[t] = 1/(1+a3*pM_s1[t]) * maxoffspr_s3      
    
    l_s1[t] = maxoffspr_s1*(1-1/(1+pM_s2[t])) 
    l_s3[t] = maxoffspr_s1*(1-1/(1+pM_s2[t])) 

#%% Popsize plot

t=np.arange(ntimesteps)
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
ax.plot(t, N_s1, alpha=0.33,color='red')
ax.plot(t, N_s2, alpha=0.33,color='green')
ax.plot(t, N_s3, alpha=0.33,color='blue')
#fig.suptitle(r'$\alpha=$'+str(alpha)+r'$, a_1=$'+str(a1)+r'$, a_3=$'+str(a3)+', b='+str(b),y=1)
ax.set_xlim(0,200)
ax.set_ylim(0,2000)
ax.set_ylabel('Species abundances')
ax.set_xlabel('Time (generations)')
plt.tight_layout()
plt.show()


#%% ADDITIVE PLOT

mat1= (v_s1[...,0].T)
mat2= (v_s2[...,0].T)
mat3= (v_s3[...,0].T)

temp_max=np.max((mat1,mat2,mat3))
temp_min=np.min((mat1,mat2,mat3))

R_r = rescale(mat1, temp_min,temp_max) #clip?
G_r = rescale(mat2, temp_min,temp_max)
B_r = rescale(mat3, temp_min,temp_max)

cmapgrn = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "green"]) #seagreen also
cmapred = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "red"])
cmapblu = matplotlib.colors.LinearSegmentedColormap.from_list("", ["black", "blue"])

blended = 1 - (1 - cmapred(R_r)) * (1 - cmapgrn(G_r)) * (1 - cmapblu(B_r))

temp_g = 1.8
blended = cNorm(blended,temp_g)


fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
pos = ax.imshow(blended,interpolation='None')
fig.suptitle(r'$\alpha=$'+str(alpha)+r'$, a_1=$'+str(a1)+r'$, a_3=$'+str(a3)+', b='+str(b),y=0.85)
ax.set_ylabel('Trait value')
ax.set_xlabel('Time (generations)')

plt.tight_layout()
plt.show()


#%% 
w_s1=v_s1*l_s1
w_s2=v_s2*l_s2
w_s3=v_s3*l_s3
showdata(v_s1)
showdata(v_s2)
showdata(v_s3)

showdata(w_s1)
showdata(w_s2)
showdata(w_s3)

showlist(w_s1.sum(1))
showlist(w_s2.sum(1))
showlist(w_s3.sum(1))

showdata(pM_s1)





#%% 


def quantilebands(mat,width=0.25):
    t=np.arange(mat.shape[1])
    return np.append(t,np.flip(t)), np.append((mat.cumsum(0)>=.5-width).argmax(0),np.flip((mat.cumsum(0)>=.5+width).argmax(0)))


def plotQuantilebands(ax, mat, widths, alpha=1, color='green'):
    for width in widths:
        x,y=quantilebands(mat,width); ax.fill(x,y,alpha=alpha/len(widths)*np.sqrt(.5-width),color=color) #alpha*(.5-width)

vrange=np.arange(nstates)[:,np.newaxis]
t=np.arange(ntimesteps)
#%% 
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111)
#ax.imshow(mat1,interpolation='None')

ax.plot(t, (vrange*mat1*nstates).mean(0), color='red'); plotQuantilebands(ax, mat1, [.25,.40,.49],color='red')

ax.plot(t,(vrange*mat2*nstates).mean(0),color='green'); plotQuantilebands(ax, mat2, [.25,.40,.49],color='green')

ax.plot(t,(vrange*mat3*nstates).mean(0),color='blue');  plotQuantilebands(ax, mat3, [.25,.40,.49],color='blue')
#ax.plot(t, (mat1.cumsum(0)>=.5).argmax(0))

fig.suptitle(r'$\alpha=$'+str(alpha)+r'$, a_1=$'+str(a1)+r'$, a_3=$'+str(a3)+', b='+str(b),y=1)
ax.set_ylabel('Trait value')
ax.set_xlabel('Time (generations)')
plt.tight_layout()
plt.show()
