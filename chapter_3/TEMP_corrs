#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jun 27 15:52:20 2023

@author: ubuntu
"""

thres_interac=100

gamma   = {}
gamma_i = {}
mass    = {}
mass_c  = {}
payoff  = {}

Gl_gamma   = [nx.from_numpy_array(M)                         for M in gammas]
Gl_gamma_i = [nx.from_numpy_array(M)                         for M in gammas_i]
Gl_mass    = [nx.from_numpy_array(M)                         for M in adjs]
# Gl_mass_c  = [nx.from_numpy_array(M >thres_interac)          for M in adjs]
Gl_mass_c  = [mx.pruning.threshold(G,thres_interac) for G in Gl_mass]
Gl_payoff  = [nx.from_numpy_array(M,create_using=nx.DiGraph) for M in payoffs]

gamma   ['name'] = 'gamma'
gamma_i ['name'] = 'gamma_i'
mass    ['name'] = 'mass'
mass_c  ['name'] = 'mass_c'
payoff  ['name'] = 'payoff'

gamma['sR']   = np.array(list(map(mx.spectralRnorm, [M for M in gammas])))
gamma_i['sR'] = np.array(list(map(mx.spectralRnorm, [M for M in gammas_i])))
payoff['sR']  = np.array(list(map(mx.spectralRnorm, [M for M in payoffs])))

gamma['mod']   = np.array(mx.mod( Gl_gamma ))
gamma_i['mod'] = np.array(mx.mod( Gl_gamma_i ))
# mass['mod']    = np.array(mx.mod( Gl_mass ))
# mass_c['mod']  = np.array(mx.mod( Gl_mass_c ))
# payoff['mod'] = mx.mod( Gl_payoff )

gamma['nodf']   =  list(map(mx.nodf, [mx.rmUnco(       M>thres_gamma)  for M in gammas]))
gamma_i['nodf'] =  list(map(mx.nodf, [mx.rmUnco(       M>thres_gamma)  for M in gammas_i]))
# mass_c['nodf']  =  list(map(mx.nodf, [mx.rmUnco(       M>thres_interac)for M in adjs]))
#payoff['nodf']  =  list(map(mx.nodf, [mx.rmUnco(np.abs(M>thres_payoff))for M in payoff]))
[nx.is_connected(G) for G in Gl_gamma]

gamma['nC']   = [nx.number_connected_components(G) for G in Gl_gamma]
gamma_i['nC'] = [nx.number_connected_components(G) for G in Gl_gamma_i]
mass['nC']    = [nx.number_connected_components(G) for G in Gl_mass]
mass_c['nC']  = [nx.number_connected_components(G) for G in Gl_mass_c]


gamma['nodes']   = {}
gamma_i['nodes'] = {}
mass['nodes']    = {}
mass_c['nodes']  = {}
payoff['nodes']  = {}

# gamma['nodes']['deg']   = [dict(G.degree()) for G in Gl_gamma   ]
# gamma_i['nodes']['deg'] = [dict(G.degree()) for G in Gl_gamma_i ]
# mass['nodes']['deg']    = [dict(G.degree()) for G in Gl_mass    ]
mass_c['nodes']['deg']  = [dict(G.degree()) for G in Gl_mass_c  ]
payoff['nodes']['deg']  = [dict(G.degree()) for G in Gl_payoff  ]

gamma['nodes']['qdeg']   = [dict(G.degree( weight='weight')) for G in Gl_gamma   ]
gamma_i['nodes']['qdeg'] = [dict(G.degree( weight='weight')) for G in Gl_gamma_i ]
mass['nodes']['qdeg']    = [dict(G.degree( weight='weight')) for G in Gl_mass    ]
mass_c['nodes']['qdeg']  = [dict(G.degree( weight='weight')) for G in Gl_mass_c  ]
payoff['nodes']['qdeg']  = [dict(G.degree( weight='weight')) for G in Gl_payoff  ]

gamma['nodes']['bc']   = [nx.betweenness_centrality(G,weight='weight') for G in Gl_gamma   ]
gamma_i['nodes']['bc'] = [nx.betweenness_centrality(G,weight='weight') for G in Gl_gamma_i ]
mass['nodes']['bc']    = [nx.betweenness_centrality(G,weight='weight') for G in Gl_mass    ]
mass_c['nodes']['bc']  = [nx.betweenness_centrality(G,weight='weight') for G in Gl_mass_c  ]
payoff['nodes']['bc']  = [nx.betweenness_centrality(G,weight='weight') for G in Gl_payoff  ]

gamma['nodes']['ec']   = [nx.eigenvector_centrality(G, max_iter=500000,weight='weight') for G in Gl_gamma   ]
gamma_i['nodes']['ec'] = [nx.eigenvector_centrality(G, max_iter=100000,weight='weight') for G in Gl_gamma_i ]
mass['nodes']['ec']    = [nx.eigenvector_centrality(G, max_iter=5000) for G in Gl_mass    ]
mass_c['nodes']['ec']  = [nx.eigenvector_centrality(G, max_iter=5000) for G in Gl_mass_c  ]
payoff['nodes']['ec']  = [nx.eigenvector_centrality(G, max_iter=1000) for G in Gl_payoff  ]

# payoff['nodes']['indeg']   = [dict(G.in_degree( )) for G in Gl_payoff]
# payoff['nodes']['outdeg']  = [dict(G.out_degree()) for G in Gl_payoff]
payoff['nodes']['qindeg']   = [dict(G.in_degree( weight='weight')) for G in Gl_payoff]
payoff['nodes']['qoutdeg']  = [dict(G.out_degree(weight='weight')) for G in Gl_payoff]


# [dict(zip(i__indeg.keys(), np.array(list(i__indeg.values()))+np.array(list(i__outdeg.values())) ))for i__indeg, i__outdeg in zip(payoff['nodes']['qindeg'],payoff['nodes']['qoutdeg'])]

nodekeys = gamma['nodes']['bc'][0].keys()

gamma['nodes']['fits']       = [ dict(zip(nodekeys, sim['fits'][-2])) for sim in simulations]
gamma_i['nodes']['fits']     = [ dict(zip(nodekeys, sim['fits'][1 ])) for sim in simulations]
# mass['nodes']['fits']        = [ dict(zip(nodekeys, sim['fits'][-1])) for sim in simulations]
# mass_c['nodes']['fits']      = [ dict(zip(nodekeys, sim['fits'][-1])) for sim in simulations]

gamma['nodes']['popsizes']   = [ dict(zip(nodekeys, sim['D'][-2]))    for sim in simulations]
gamma_i['nodes']['popsizes'] = [ dict(zip(nodekeys, sim['D'][1 ]))    for sim in simulations]
# mass['nodes']['popsizes']    = [ dict(zip(nodekeys, sim['D'][-1]))    for sim in simulations]
# mass_c['nodes']['popsizes']  = [ dict(zip(nodekeys, sim['D'][-1]))    for sim in simulations]

payoff['nodes']['lv_mutu']   = [ dict(zip(nodekeys, np.nan_to_num( ((A_e>0) & (A_e.T>0)).sum(0)                          / (A_e!=0).sum(0)))) for A_e in payoffs]
payoff['nodes']['lv_comp']   = [ dict(zip(nodekeys, np.nan_to_num( ((A_e<0) & (A_e.T<0)).sum(0)                          / (A_e!=0).sum(0)))) for A_e in payoffs]
payoff['nodes']['lv_pred']   = [ dict(zip(nodekeys, np.nan_to_num((((A_e>0) & (A_e.T<0)) | ((A_e<0) & (A_e.T>0))).sum(0) / (A_e!=0).sum(0)))) for A_e in payoffs]

gamma['nodes']['power_mutu']   = [dict(zip(nodekeys,M.mean(0))) for M in mutu]
gamma['nodes']['power_comp']   = [dict(zip(nodekeys,M.mean(0))) for M in comp]
gamma['nodes']['power_pred']   = [dict(zip(nodekeys,M.mean(0))) for M in pred]

gamma['nodes']['power_mutu_delta'] = [dict(zip(nodekeys,(M-Mi).mean(0))) for M, Mi in zip(mutu,mutu_i)]
gamma['nodes']['power_comp_delta'] = [dict(zip(nodekeys,(M-Mi).mean(0))) for M, Mi in zip(comp,comp_i)]
gamma['nodes']['power_pred_delta'] = [dict(zip(nodekeys,(M-Mi).mean(0))) for M, Mi in zip(pred,pred_i)]

matList = [
gamma   ,
gamma_i ,
mass    ,
mass_c  ,
payoff  ]

#%%


'''
import pandas as pd

df = np.array([
list(gamma['nodes'].values())   ,
list(gamma_i['nodes'].values()) ,
list(mass['nodes'].values())    ,
list(mass_c['nodes'].values())  ,
list(payoff['nodes'].values())  ])

gamma['nodes'].keys()
list(gamma['nodes'].values())[0]

np.array(gamma['nodes'].values())



list(map(np.array, gamma['nodes'].values()))


len(gamma['nodes']['qdeg'][0])

len(gamma['nodes']['deg'])

cs  = [np.tril(np.corrcoef(k[:,i,:])) for i in range(len(simulations))]


#list(gamma['nodes'].keys())
keys = gamma['nodes']['deg'][0].keys()
values = [[d[key] for key in keys] for d in gamma['nodes']['deg']]
'''

#%%
l=[]
varnames = []
for mclass in matList:
    mname = mclass['name']
    for key in mclass['nodes'].keys():
        # print(mname + key)
        nodenames = mclass['nodes'][key][0].keys()
        values = [[d[nodename] for nodename in nodenames] for d in mclass['nodes'][key]]
        varnames.append(mname + '_' + key)
        l.append(values)

k=np.array(l)
k.shape


cs  = np.array([np.tril(np.corrcoef(k[:,i,:]),-1) for i in range(len(simulations))])
cs = np.nan_to_num(cs) # !!!
# cs  = np.array([       (np.corrcoef(k[:,i,:])) for i in range(len(simulations))])
cs_flat  = cs.reshape((len(simulations),np.prod(cs[0].shape)))


switch_backend('module://matplotlib_inline.backend_inline')

mx.showdata(np.corrcoef(cs_flat.T), symmetry=True, colorbar=True)

sd(cs[0], symmetry=True, colorbar=True)
sd(cs_flat, symmetry=True, colorbar=True)


cornames= np.empty((len(varnames),len(varnames)),dtype='<U64')
for i, iname in enumerate(varnames):
    for j, jname in enumerate(varnames):
        cornames[i,j] = iname + '_X_' + jname

cornames_flat = cornames.flatten()


def tmp_nodecorrs(name):
    return cs_flat[ :,np.where(cornames_flat==name)[0][0]]


#%%
'''
hivarIndexes = np.where(cs_flat.var(axis=0)>1e-2)

cs_flat_hivar = np.squeeze(cs_flat[:,hivarIndexes])
cornames_flat_hivar = cornames_flat[hivarIndexes]
sd(cs_flat,       symmetry=True, colorbar=False)
sd(cs_flat_hivar, symmetry=True, colorbar=False)
'''
#%%
testvars=[]
testvarnames = []
for mclass in matList:
    print(mclass['name'])
    for key in mclass.keys():
        if key != 'name' and key != 'nodes':
            testvars.append(mclass[key])
            testvarnames.append(mclass['name'] + '_' + key)
            print('\t'+mclass['name'] + '_' + key)
            

testvars = np.array(testvars)
testvars = np.append(testvars, [
    a,
    d,
    c,
    n_mutu,
    n_pred,
    n_comp,
    power_mutu,
    power_pred,
    power_comp,
    total_Lv_mutu,
    total_Lv_pred,
    total_Lv_comp],
    axis=0)

    
testvarnames += [
    'assortmat',
    'freqdep',
    'connectance',
    'n_mutu',
    'n_pred',
    'n_comp',
    'power_mutu',
    'power_pred',
    'power_comp',
    'total_Lv_mutu',
    'total_Lv_pred',
    'total_Lv_comp']


#%%
# switch_backend('qtagg') # or 'qtagg'

'''
plt.imshow(cs_flat_hivar, cmap='seismic')
plt.xticks(range(cs_flat_hivar.shape[1]), cornames_flat_hivar)
plt.xticks(rotation='vertical')
plt.figure(figsize=(64, 18))
'''

switch_backend('module://matplotlib_inline.backend_inline')

#%%
'''
I = np.newaxis
plt.scatter(testvars[1],cs_flat[:,:5].T)


for i in range(cs_flat.shape[1]):
    plt.plot(gamma['sR'], cs_flat.T[i], label=f'Variable {i+1}')


#%%

np.corrcoef(np.append(testvars, cs_flat.T,axis=0))
cs_flat.T.shape

#%%
#CORRS= np.corrcoef(cs_flat.T)
CORRS = np.corrcoef(np.append(cs_flat.T, testvars, axis=0))

sd(CORRS, symmetry=True, colorbar=True)
sd(np.corrcoef(cs_flat_hivar.T), symmetry=True, colorbar=True)


top = np.max([np.abs(np.nanmax(CORRS)),np.abs(np.nanmin(CORRS))])
plt.imshow(CORRS, interpolation='none', cmap='seismic',vmax=top,vmin=-top)
plt.plot((100,0),(500,0))

'''

#%%
CORRS = np.corrcoef(np.append(cs_flat.T, testvars, axis=0))[cs_flat.T.shape[0]:,:cs_flat.T.shape[0]]


sorted_indices = np.argsort(np.abs(CORRS), axis=None)[::-1]
row_indices, col_indices = np.unravel_index(sorted_indices, CORRS.shape)
sorted_values = CORRS[row_indices, col_indices]



endofnan = np.where(np.isnan(sorted_values))[0][-1]+1
sorted_values_nn  = sorted_values[endofnan:]
row_indices_nn      = row_indices[endofnan:]
col_indices_nn      = col_indices[endofnan:]


# [testvarnames[i]  for i in row_indices_nn][:4]
# [cornames_flat[j] for j in col_indices_nn][:4]
# sorted_values_nn

#%% all
switch_backend('module://matplotlib_inline.backend_inline')
head = (00,20)

for i,j in zip(row_indices_nn[head[0]:head[1]], col_indices_nn[head[0]:head[1]]):
    #testvarnames[i],cornames_flat[j]
    plt.scatter(testvars[i],cs_flat.T[j])
    plt.xlabel(testvarnames[i])
    plt.ylabel(cornames_flat[j])
    plt.show()

#%% Search x (and y)
'''
if nothing is found, try head head = (00,len(cornames_flat)) 
'''
switch_backend('module://matplotlib_inline.backend_inline')
head = (0,100) 
import re
forcedvarname = 'freqdep'
cornamepattern = '.*' # '.*' for no filter

targetrows = row_indices_nn[np.where(row_indices_nn == np.where(np.array(testvarnames)==forcedvarname)[0][0])]
targetcols = col_indices_nn[np.where(row_indices_nn == np.where(np.array(testvarnames)==forcedvarname)[0][0])]
for i,j in zip(targetrows[head[0]:head[1]], targetcols[head[0]:head[1]]):
# for i,j in zip(targetrows, targetcols):
    if bool(re.search(cornamepattern, cornames_flat[j])): 
        print(cornames_flat[j])
        plt.scatter(testvars[i],cs_flat.T[j])
        plt.xlabel(testvarnames[i])
        plt.ylabel(cornames_flat[j])
        plt.show()

# for i,j in zip(row_indices_nn[head[0]:head[1]], col_indices_nn[head[0]:head[1]]):
#     print(CORRS[i,j])

#       print('\n'.join([tmp for tmp in cornames_flat if bool(re.search('payoff_deg_X_mass_c_ec', tmp))]))

#%% Search only y
switch_backend('module://matplotlib_inline.backend_inline')
head = (00,100)
import re


'payoff_ec_X_mass_c_qdeg'
'payoff_deg_X_mass_c_ec'
np.where(cornames_flat == 'payoff_deg_X_mass_c_ec')[0][0]
cornamepattern='_delta'

for i,j in zip(row_indices_nn[head[0]:head[1]], col_indices_nn[head[0]:head[1]]):
    if bool(re.search(cornamepattern, cornames_flat[j])): # '.*' for no filter
        print(cornames_flat[j])
        plt.scatter(testvars[i],cs_flat.T[j])
        plt.xlabel(testvarnames[i])
        plt.ylabel(cornames_flat[j])
        plt.show()
        

#%%

switch_backend('qt5agg') # or 'qtagg'
print('\n'.join(cornames_flat))
#%%
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(n_mutu,
                    payoff['sR'],
                    cs_flat[ :,np.where(cornames_flat=='payoff_qoutdeg_X_payoff_qindeg')[0][0]],
                    c=gamma['sR'], cmap='turbo')
ax.set_xlabel(r"x", fontsize=16)
ax.set_ylabel(r"y") 
# plt.legend(handles=[scatter1, scatter2])
plt.colorbar(scatter1)
plt.show()


#%% important plot 1
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(tmp_nodecorrs('payoff_qoutdeg_X_payoff_bc'), # can be gamma_bc instead payoff_bc
                    tmp_nodecorrs('payoff_qindeg_X_payoff_bc'),
                    d,
                    c=power_mutu, cmap='turbo')
ax.set_xlabel(r"x", fontsize=16)
ax.set_ylabel(r"y")
# plt.legend(handles=[scatter1, scatter2])
plt.colorbar(scatter1)
plt.show()

#%% important plot 2
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(#tmp_nodecorrs('payoff_qdeg_X_gamma_bc'),
                     # tmp_nodecorrs('payoff_bc_X_payoff_qdeg'),
                     # tmp_nodecorrs('payoff_qindeg_X_payoff_bc'),
                     n_comp,
                    d,
                    
                    # gamma['mod']-gamma_i['mod'],
                    tmp_nodecorrs('mass_bc_X_mass_qdeg'),
                    # c=tmp_nodecorrs('payoff_qdeg_X_mass_bc'), cmap='jet')
                    c=gamma['mod']-gamma_i['mod'], cmap='bwr', norm=matplotlib.colors.TwoSlopeNorm(vmin=-.25, vcenter=0, vmax=.25))
ax.set_xlabel(r"x", fontsize=16)
ax.set_ylabel(r"y")
# plt.legend(handles=[scatter1, scatter2])
plt.colorbar(scatter1)
plt.show()

#%% important plot 3
switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(tmp_nodecorrs('payoff_qindeg_X_payoff_bc'),
                      # tmp_nodecorrs('payoff_bc_X_payoff_qdeg'),
                     # tmp_nodecorrs('payoff_qindeg_X_payoff_bc'),
                     
                    d,
                    
                    # mass_c['nC'],
                    # mass['mod'],
                    tmp_nodecorrs('mass_qdeg_X_gamma_bc'),
                    # tmp_nodecorrs('payoff_bc_X_gamma_qdeg'),
                    # tmp_nodecorrs('gamma_bc_X_gamma_qdeg'),
                    # tmp_nodecorrs('mass_bc_X_mass_qdeg'),
                    c=n_comp, cmap='winter_r')
ax.set_xlabel(r"X", fontsize=16)
ax.set_ylabel(r"freq. dependence")
ax.set_zlabel(r"q. degree of bridges")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label='number of competitions')
plt.show()

#%% important plot 4
'''
under positive frequency dependence, mutualistic and competitor networks split into two clusters
competitors
'''
switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
                    # tmp_nodecorrs('gamma_ec_X_gamma_bc') - tmp_nodecorrs('gamma_i_ec_X_gamma_i_bc'),
                    # tmp_nodecorrs('payoff_qdeg_X_gamma_ec'),
                    d,
                    tmp_nodecorrs('mass_qdeg_X_gamma_bc'),
                    
                    # tmp_nodecorrs('gamma_popsizes_X_gamma_bc'),
                    tmp_nodecorrs('gamma_fits_X_gamma_bc'),
                    # c=gamma['sR'], cmap='jet')
                    # c= tmp_nodecorrs('payoff_lv_mutu_X_payoff_deg'), cmap='bwr', norm=matplotlib.colors.TwoSlopeNorm(vmin=-.25, vcenter=0, vmax=.25))
                    # c= tmp_nodecorrs('payoff_lv_mutu_X_mass_bc'),cmap='bwr', norm=matplotlib.colors.TwoSlopeNorm(vmin=-.25, vcenter=0, vmax=.25))
                    c=n_comp, cmap='autumn_r')
ax.set_xlabel(r"x", fontsize=16)
ax.set_ylabel(r"y")
# plt.legend(handles=[scatter1, scatter2])
plt.colorbar(scatter1)
plt.show()
#%% important plot 5
switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
                    # tmp_nodecorrs('gamma_ec_X_gamma_bc') - tmp_nodecorrs('gamma_i_ec_X_gamma_i_bc'),
                    # tmp_nodecorrs('payoff_qdeg_X_gamma_ec'),
                    a,
                    # tmp_nodecorrs('mass_qdeg_X_gamma_ec'),
                    
                    # tmp_nodecorrs('gamma_popsizes_X_gamma_bc'),
                    # tmp_nodecorrs('mass_bc_X_gamma_popsizes'),
                    
                    tmp_nodecorrs('payoff_ec_X_payoff_qdeg'),
                    # n_comp,
                    
                    
                    
                    
                    tmp_nodecorrs('payoff_deg_X_mass_c_deg'),

                    
                    # payoff_ec_X_mass_c_ec
                    # payoff_ec_X_mass_c_deg
                    # payoff_ec_X_mass_c_qdeg
                    # payoff_ec_X_payoff_deg
                    # payoff_deg_X_mass_c_ec
                    # payoff_deg_X_mass_c_deg
                    
                    
                    # tmp_nodecorrs('payoff_deg_X_mass_c_ec'),
                    
                    # c=power_pred, cmap='autumn_r')
                    # c= tmp_nodecorrs('payoff_lv_mutu_X_payoff_deg'), cmap='bwr', norm=matplotlib.colors.TwoSlopeNorm(vmin=-.25, vcenter=0, vmax=.25))
                    # c= tmp_nodecorrs('mass_bc_X_mass_qdeg'),cmap='bwr', norm=matplotlib.colors.TwoSlopeNorm(vmin=-.25, vcenter=0, vmax=.25))
                    # c= tmp_nodecorrs('payoff_ec_X_mass_c_qdeg'),cmap='bwr', norm=matplotlib.colors.TwoSlopeNorm(vmin=-.25, vcenter=0, vmax=.25))
                    c=n_comp, cmap='autumn_r')

ax.set_xlabel(r"x", fontsize=16)
ax.set_ylabel(r"y")
# plt.legend(handles=[scatter1, scatter2])
plt.colorbar(scatter1)
plt.show()

#%%
tmp_nodecorrs('payoff_bc_X_payoff_qdeg')
mass_c.keys()
mass_c['mod']
tmp_nodecorrs('payoff_qoutdeg_X_payoff_qindeg')

#%%

switch_backend('module://matplotlib_inline.backend_inline')

plt.scatter(
    [list(payoff['nodes']['ec'][i].values())for i in range(len(simulations))],
    [list(payoff['nodes']['bc'] [i].values())for i in range(len(simulations))],
    s=0.1
    )
plt.show()


plt.scatter(
    [list(payoff['nodes']['qdeg'][i].values())for i in range(len(simulations))],
    [list(gamma_i['nodes']['ec'] [i].values())for i in range(len(simulations))],
    s=0.1
    )
plt.show()

plt.scatter(
    [list(mass_c['nodes']['bc'][i].values())for i in range(len(simulations))],
    [list(payoff['nodes']['bc'] [i].values())for i in range(len(simulations))],
    s=0.1
    )
plt.show()



plt.scatter(
    [list(mass['nodes']['qdeg'][i].values())for i in range(len(simulations))],
    [list(payoff['nodes']['qdeg'] [i].values())for i in range(len(simulations))],
    s=0.5,c=np.repeat(n_comp,N),cmap='autumn_r'
    )
plt.show()

plt.scatter(
    [list(payoff['nodes']['qdeg'] [i].values())for i in range(len(simulations))],
    [(list(mass['nodes']['qdeg'][i].values()))for i in range(len(simulations))],
    c=(np.repeat(a,N))**2,cmap='cool',s=1.5
    )
plt.show()
#%%

switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter((np.repeat(n_comp,N)),
                      [list(gamma['nodes']['bc']  [i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['qdeg'][i].values())for i in range(len(simulations))],
                    c=(np.repeat(d,N)), cmap='plasma_r',s=7,alpha=0.5)
                    # c=[list(mass['nodes']['bc']   [i].values())for i in range(len(simulations))], cmap='plasma',s=10)
ax.set_xlabel(r"fdep", fontsize=16)
ax.set_ylabel(r"BC$_{\gamma}$")
ax.set_zlabel(r"qDEG$_{\gamma}$")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"fdep")
plt.show()

#%%
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter((np.repeat(n_comp,N)),
                      (np.repeat(d,N)),
                      [list(gamma['nodes']['qdeg'][i].values())for i in range(len(simulations))],
                    c=[list(gamma['nodes']['bc']  [i].values())for i in range(len(simulations))], cmap='cividis',s=7,alpha=0.8,norm=matplotlib.colors.LogNorm())
                    # c=[list(mass['nodes']['bc']   [i].values())for i in range(len(simulations))], cmap='plasma',s=10)
ax.set_xlabel(r"n$_{comp}$", fontsize=16)
ax.set_ylabel(r"fdep")
ax.set_zlabel(r"qDEG$_{\gamma}$")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"BC$_{\gamma}$")
plt.show()



#%%
'''
Quantitative degree of Mass "caps" the maximum fitness the species can reach. 
In non-bridge species, positive frequency dependence (fd+) fitness allows to significantly increase the Quantitative degree of Mass. 
(fd+ allows species to be more promiscuous in interactions, probably due to multimodal distributions).
As the Quantitative degree of Mass is increased, the cap is pushed beyond. Therefore, species with highest fitness have:
    - low betweenness centrality (all matrices).
    - fd+
    - Mass Quantitative degree

Furthermore, species closest to the imposed cap tend to be mutualists, independently of the other variables or how high the cap is.
'''

switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
                      [list(mass['nodes']['bc']  [i].values())for i in range(len(simulations))], # try with payoff and gamma
                      [list(mass['nodes']['qdeg'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))],
                    # c=[list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))], cmap='jet',s=7,alpha=0.8,norm=matplotlib.colors.LogNorm())
                    c=(np.repeat(d,N)),norm=matplotlib.colors.TwoSlopeNorm(vmin=-1, vcenter=0, vmax=1),cmap='bwr',s=1)
                    # c=[list(payoff['nodes']['lv_mutu'][i].values())for i in range(len(simulations))], cmap='jet',s=7,alpha=0.8)
                    
ax.set_xlabel(r"BC$_{\gamma}$", fontsize=16)
ax.set_ylabel(r"qDEG$_{M}$", fontsize=16)
ax.set_zlabel(r"$\bar{w}_{\gamma}$")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"fdep")
plt.show()


#%%

switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(8,6)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
                      [list(gamma['nodes']['power_pred']  [i].values())for i in range(len(simulations))], # try with payoff and gamma
                      [list(gamma['nodes']['power_comp'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))],
                    # c=[list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))], cmap='jet',s=7,alpha=0.8,norm=matplotlib.colors.LogNorm())
                    c=(np.repeat(d,N)),norm=matplotlib.colors.TwoSlopeNorm(vmin=-1, vcenter=0, vmax=1),cmap='bwr',s=1)
                    # c=[list(payoff['nodes']['lv_mutu'][i].values())for i in range(len(simulations))], cmap='jet',s=7,alpha=0.8)
                    
ax.set_xlabel(r"BC$_{\gamma}$", fontsize=16)
ax.set_ylabel(r"comp. power", fontsize=16)
ax.set_zlabel(r"$\bar{w}_{\gamma}$")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"fdep")
plt.show()


#%%
'''
An increase in predation power (increase in the sum of gamma weights in predation links via increased trait matching) is usually negatively correlated (exponential decay) with betweenness centrality of the mass network.
I.e., a high predation activity prevents a species to become a bridge.
This great increase in predation power in non-bridge species is potentiated by overall positive frequency dependence in the network (together with enough mutualistic partners?).
Also overall positive frequency dependence increases mass betweenness centrality when predation does not increase.
Although the higher the payoff degree, the higher mass betweenness centrality or predation increase, 
it finds a sweet point at payoff eigenvector centrality of 0.3. 
'''
switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(12,9)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
                      # [list(gamma['nodes']['power_pred_delta'][i].values())for i in range(len(simulations))],
                      [list(mass_c['nodes']['bc'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['ec'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['power_pred_delta']  [i].values())for i in range(len(simulations))], # try with payoff and gamma
                    # c=[list(gamma['nodes']['power_pred_delta']  [i].values())for i in range(len(simulations))], norm=matplotlib.colors.TwoSlopeNorm(vmin=-.1, vcenter=0, vmax=.1),cmap='bwr',s=10)
                    c=(np.repeat(d,N)),norm=matplotlib.colors.TwoSlopeNorm(vmin=-1, vcenter=0, vmax=1),cmap='bwr',s=10)
                    # c=[list(payoff['nodes']['lv_mutu'][i].values())for i in range(len(simulations))], cmap='jet',s=7,alpha=0.8)
                    
ax.set_xlabel(r"BC$_{M}$", fontsize=16)
ax.set_ylabel(r"DEG$_{G}$", fontsize=16)
ax.set_zlabel(r"$\Delta_{pred}$")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"fdep")
plt.show()

#%%
switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(12,9)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
                      # [list(gamma['nodes']['power_pred_delta'][i].values())for i in range(len(simulations))],
                      [list(mass_c['nodes']['ec'][i].values())for i in range(len(simulations))],
                      [list(payoff['nodes']['ec'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['power_mutu_delta']  [i].values())for i in range(len(simulations))], # try with payoff and gamma
                    c=[list(payoff['nodes']['qdeg']  [i].values())for i in range(len(simulations))], norm=matplotlib.colors.TwoSlopeNorm(vmin=-.5, vcenter=0, vmax=.5),cmap='bwr',s=10)
                    # c=(np.repeat(c,N)),cmap='viridis',s=10)
                    
                    
                    
ax.set_xlabel(r"EC$_{M}$", fontsize=16)
ax.set_ylabel(r"DEG$_{G}$", fontsize=16)
ax.set_zlabel(r"$\Delta_{pred}$")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"node strength")
plt.show()


#%%
switch_backend('qt5agg') # or 'qtagg'

R = np.array([list(payoff['nodes']['lv_pred']  [i].values()) for i in range(len(simulations))]).flatten()
G = np.array([list(payoff['nodes']['lv_mutu']  [i].values()) for i in range(len(simulations))]).flatten()
B = np.array([list(payoff['nodes']['lv_comp']  [i].values()) for i in range(len(simulations))]).flatten()
colors = ['#%02x%02x%02x' % (r,g,b) for r,g,b in (mx.renormalize((R,G,B))*255).astype('int').T]

fig = plt.figure(figsize=(12,9)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(  np.repeat(a,N),
                       # [list(payoff['nodes']['lv_mutu'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['power_mutu_delta'][i].values())for i in range(len(simulations))],
                      [list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))],
                      # [list(gamma['nodes']['power_mutu_delta']  [i].values())for i in range(len(simulations))], # try with payoff and gamma
                    # c=[list(gamma['nodes']['power_comp_delta']  [i].values())for i in range(len(simulations))], norm=matplotlib.colors.TwoSlopeNorm(vmin=-.05, vcenter=0, vmax=.05),cmap='bwr',s=10)
                    c=colors)
                    # c=(np.repeat(d,N)),norm=matplotlib.colors.TwoSlopeNorm(vmin=-1, vcenter=0, vmax=1),cmap='bwr',s=10)
                    # c=(np.repeat(a,N)),cmap='viridis',s=10)
                    # c=[list(payoff['nodes']['lv_pred'][i].values())for i in range(len(simulations))], cmap='viridis',s=7,alpha=0.8)
                    
ax.set_xlabel(r"x", fontsize=16)
ax.set_ylabel(r"y", fontsize=16)
ax.set_zlabel(r"z")
# plt.legend(handles=[scatter1, scatter2])
#plt.colorbar(scatter1)
plt.colorbar(scatter1,ax=ax, label=r"w")
plt.show()






#%%
'''
positive assortative mating increases max fitness together with node strength
'''

# R = np.array([list(gamma['nodes']['ec']  [i].values()) for i in range(len(simulations))]).flatten()
# G = np.array([list(gamma['nodes']['qdeg']  [i].values()) for i in range(len(simulations))]).flatten()
# B = np.array([list(gamma['nodes']['fits']  [i].values()) for i in range(len(simulations))]).flatten()
R = np.array([list(gamma['nodes']['power_pred']  [i].values()) for i in range(len(simulations))]).flatten()
G = np.array([list(gamma['nodes']['power_mutu']  [i].values()) for i in range(len(simulations))]).flatten()
B = np.array([list(gamma['nodes']['power_comp']  [i].values()) for i in range(len(simulations))]).flatten()
# R_power = np.array([list(gamma['nodes']['power_pred']  [i].values()) for i in range(len(simulations))]).flatten()
# G_power = np.array([list(gamma['nodes']['power_mutu']  [i].values()) for i in range(len(simulations))]).flatten()
# B_power = np.array([list(gamma['nodes']['power_comp']  [i].values()) for i in range(len(simulations))]).flatten()
# R_lv = np.array([list(payoff['nodes']['lv_pred'][i].values()) for i in range(len(simulations))]).flatten()
# G_lv = np.array([list(payoff['nodes']['lv_mutu'][i].values()) for i in range(len(simulations))]).flatten()
# B_lv = np.array([list(payoff['nodes']['lv_comp'][i].values()) for i in range(len(simulations))]).flatten()
# R = np.nan_to_num(R_power / R_lv)
# G = np.nan_to_num(G_power / G_lv)
# B = np.nan_to_num(B_power / B_lv)

rgblist = np.array([
mx.cNorm(mx.renormalize(R),5)*255,
mx.cNorm(mx.renormalize(G),5)*255,
mx.cNorm(mx.renormalize(B),5)*255]).astype('int').T
# (1-mx.cNorm(mx.renormalize(R),5))*255,
# (1-mx.cNorm(mx.renormalize(G),5))*255,
# (1-mx.cNorm(mx.renormalize(B),5))*255]).astype('int').T
colors = ['#%02x%02x%02x' % (r,g,b) for r,g,b in rgblist]
# colors = mx.graphictools.RGB(R,G,B,same=False)

switch_backend('qt5agg') # or 'qtagg'
fig = plt.figure(figsize=(12,9)); ax = fig.add_subplot(111, projection='3d')
scatter1=ax.scatter(
            # [list(payoff['nodes']['qindeg']  [i].values())for i in range(len(simulations))],
            # [list(payoff['nodes']['qoutdeg']  [i].values())for i in range(len(simulations))], 
                       # [list(gamma['nodes']['power_pred_delta'][i].values())for i in range(len(simulations))],
                         (np.repeat(d,N)),
                        # (np.repeat(c,N)),
                         # [list(gamma['nodes']['popsizes'][i].values())for i in range(len(simulations))],
                         #
                           # [list(payoff['nodes']['lv_comp']  [i].values())for i in range(len(simulations))],
                            [list(payoff['nodes']['lv_mutu']  [i].values())for i in range(len(simulations))],
                            # [list(gamma['nodes']['qdeg']  [i].values())for i in range(len(simulations))], #mass_c or payoff
                         # (np.repeat(gamma['mod'],N)),
                         # (np.repeat(total_Lv_mutu,N)),
                        
                         # [list(mass_c['nodes']['bc'] [i].values())for i in range(len(simulations))],
                         # [list(gamma['nodes']['power_mutu_delta'][i].values())for i in range(len(simulations))],
                          [list(gamma['nodes']['popsizes'][i].values()) for i in range(len(simulations))],
                         # np.clip([list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))],0,50),
                        # (np.repeat(n_mutu,N)),
                    
                    # 
                    # c=[list(payoff['nodes']['deg']  [i].values())for i in range(len(simulations))],cmap='jet',s=10)
                    # c=[list(payoff['nodes']['qdeg']  [i].values())for i in range(len(simulations))], norm=matplotlib.colors.TwoSlopeNorm(vmin=-.05, vcenter=0, vmax=.05),cmap='bwr',s=10)
                    # c=[list(payoff['nodes']['lv_mutu']  [i].values())for i in range(len(simulations))],cmap='viridis',s=10)
                    # c=np.clip([list(gamma['nodes']['fits'][i].values())for i in range(len(simulations))],0,50), cmap='plasma',s=10,norm=matplotlib.colors.LogNorm())
                    # c=(np.repeat(a,N)),s=20)
                    # c=(np.repeat(gamma['mod'],N)),s=20)
                    
                    c=colors,s=15)
                    
ax.set_xlabel(r"d", fontsize=16)
ax.set_ylabel(r"node strength", fontsize=16)
ax.set_zlabel(r"population size")


# plt.legend(handles=[scatter1, scatter2])
plt.colorbar(scatter1)
# plt.colorbar(scatter1,ax=ax, label=r"node strength")
plt.show()

payoff['nodes'].keys()
mass_c['nodes'].keys()
gamma['nodes'].keys()


#%%
fig = plt.figure(figsize=(9,6)); ax = fig.add_subplot(111)
scatter1=ax.scatter(
                    (np.repeat(d,N)),
                    [list(gamma['nodes']['popsizes'][i].values()) for i in range(len(simulations))],
                    # c=list(map(mx.graphictools.hex_color_invert_hue, colors)),s=15)
                    c=colors,s=15,alpha=0.5)
ax.set_xlabel(r"d", fontsize=16)
ax.set_ylabel(r"equilibrium population size")

plt.show()

#%%
switch_backend('module://matplotlib_inline.backend_inline')
states = np.linspace(ps[0],ps[1], nstates)
statesdiff=np.outer(np.ones(nstates),states)-np.outer(states,np.ones(nstates))
sd([evo.interactors.pM(statesdiff,alpha=1/i__a**2) for i__a in a][1])
sd(evo.interactors.pM(statesdiff,alpha=1/7**2))

#%%

mx.showlist(simulations[197]['dist_avgs'])
sd(payoffs[197], symmetry=True, colorbar=True)
G = Gl_payoff[197]
cycles = nx.simple_cycles(G)
cyclist = [cycle for cycle in cycles]
cycBasis = nx.cycle_basis(G.to_undirected())
nx.draw(G);plt.show() 
#!!!

cycle_graph = nx.Graph()
for cycle in cycBasis:
    for i in range(len(cycle)):
        cycle_graph.add_edge(cycle[i], cycle[(i + 1) % len(cycle)])


plt.figure(figsize=(6, 6))
pos = nx.spring_layout(cycle_graph)
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500, edge_color='#FF5555', width=0.2)
nx.draw_networkx_edges(cycle_graph, pos, edgelist=cycBasis, edge_color='black', width=2.0)
plt.title('Graph with Cycle Basis')
plt.show()




    

    
weighted_cycles = [cycle for cycle in cyclist if sum(G[u][v]['weight'] for u, v in zip(cycle, cycle[1:] + cycle[:1])) != 0]
cycle = cyclist[:20]

# list(zip(cycle, cycle[1:]  + cycle[:1]))
# list(zip(cycle, cycle[-1:] + cycle[:-1]))

dir1 = np.array([G[u][v]['weight'] for u, v in zip(cycle, cycle[1:]  + cycle[:1] )])
dir2 = np.array([G[u][v]['weight'] for u, v in zip(cycle, cycle[-1:] + cycle[:-1])])

dir1 * dir2

np.prod(dir1)
np.prod(dir2)

cyclist[0]


cycleweights_Sum = dict(zip(list(G.nodes()), [[]]*len(G.nodes())))
cycleweights_Prod= dict(zip(list(G.nodes()), [[]]*len(G.nodes())))
wlists = []
wlistp = []
lenlist = []
for cycle in cyclist:
    dir1 = np.array([G[u][v]['weight'] for u, v in zip(cycle, cycle[1:]  + cycle[:1] )])
    # dir2 = np.array([G[u][v]['weight'] for u, v in zip(cycle, cycle[-1:] + cycle[:-1])])
    cycleweight_s = np.sum(dir1)
    cycleweight_p = np.prod(dir1)
    # for u in cycle:
    #     cycleweights_Sum[u].append(cycleweight_s / len(cycle))
    #     cycleweights_Prod[u].append(cycleweight_p/ len(cycle))
    wlists.append(cycleweight_s)
    wlistp.append(cycleweight_p)
    lenlist.append(len(cycle))
    
wlists   = np.array(wlists)
wlistp   = np.array(wlistp)
lenlist = np.array(lenlist)
wlist / lenlist


data=wlists
plt.hist(data, bins=np.linspace(min(data), max(data),20), edgecolor='black', alpha=0.5, rwidth=0.8, histtype='step');plt.yscale('log')
np.mean(wlists)


del(cyclist)


[[key, np.mean(value)] for key, value in cycleweights_Prod.items()]


average_cycle_weightsums =[]
for i, G in enumerate(Gl_payoff):
    print(i/len(Gl_payoff))
    cycles = nx.simple_cycles(G)
    cyclist = [cycle for cycle in cycles]
    wlists = [np.sum([G[u][v]['weight'] for u, v in zip(cycle, cycle[1:]  + cycle[:1] )]) for cycle in cyclist]
    average_cycle_weightsums.append(np.mean(wlists))


#%% 

switch_backend('module://matplotlib_inline.backend_inline')

import matplotlib.animation as animation
simID=55
adjs  , mutu  , comp  , pred  , gammas   = evo.getADJs(simulations, simID=simID,return_gammas=True)
sim = simulations[simID]

rsc = mx.rescale(sim['fits'])
pos = nx.layout.kamada_kawai_layout(nx.from_numpy_array(gammas[0]))
fig = plt.figure(figsize=(16,12)); ax = fig.add_subplot(111)
#div = make_axes_locatable(ax)
smooth=0.85
def frame(t):
    print(t)
    global pos
    ax.clear()
    G=nx.from_numpy_array(gammas[t]) # or gamma
    pos_new=nx.layout.fruchterman_reingold_layout(G, weight='weight', pos=pos,threshold=1e-8,iterations=20) # threshold=1e-10,iterations=10
    pos = dict(zip(G.nodes(), list((np.array(list(pos.values()))*smooth + np.array(list(pos_new.values()))*(1-smooth)))))
        
    # linewidths = list(1*np.array(list(nx.get_edge_attributes(G, 'weight').values())))
    # linewidths = mx.cNorm(mx.renormalize(list(1*np.array(list(nx.get_edge_attributes(G, 'weight').values())))),5)*2
    linewidths =          mx.renormalize(list(1*np.array(list(nx.get_edge_attributes(G, 'weight').values()))))*2
    # node_weights = dict(zip(G.nodes(), rsc[t].tolist()))
    # nx.set_node_attributes(G, node_weights, "weight")
    # cmap = plt.cm.get_cmap("cool_r")
    
    #forces = np.array([sum([data['weight'] for _, _, data in G.edges(node, data=True)]) for node in G.nodes])

    # node_colors = {node: cmap(weight) for node, weight in node_weights.items()}
    colors = list(zip(
    mx.cNorm(mx.renormalize(pred[t].mean(0)),5),
    mx.cNorm(mx.renormalize(mutu[t].mean(0)),5),
    mx.cNorm(mx.renormalize(comp[t].mean(0)),5)
    ))
    
    nx.draw_networkx(G, ax=ax, pos=pos, 
                      width=linewidths, 
                     edge_color=linewidths, 
                     edge_cmap=plt.cm.coolwarm, 
                     node_size= sim['D'][t], 
                     # node_color=list(node_colors.values())) #node_size= force ?
                     node_color=colors)

    # ---------------------------------------------------------------------
    
    ax.set_title('t = {}'.format(t))
    plt.show()
    return ax

sim['fits'].shape[0]

# timecode = str(time.time())
# timecode = '_test'
ani = animation.FuncAnimation(fig, frame, frames=len(adjs), interval=20, blit=False) # 
# ani.save('../figures/gif/net' + timecode +'.gif')


pattern = r'SIMULATIONS_(.*?_.*?)_'
easyname = re.search(pattern, filename).group(1)

gifname = easyname + '_' + str(simID)
ani.save(img_path / str('gif/' + gifname +'.gif'))
#%%
fig = plt.figure(figsize=(16,12)); ax = fig.add_subplot(111)
#div = make_axes_locatable(ax)
smooth=0.75
t=1000
print(t)
global pos
ax.clear()
G=nx.from_numpy_array(adjs[t]) # or gamma
pos_new=nx.layout.fruchterman_reingold_layout(G, weight='weight', pos=pos,threshold=1e-8,iterations=20) # threshold=1e-10,iterations=10
pos = dict(zip(G.nodes(), list((np.array(list(pos.values()))*smooth + np.array(list(pos_new.values()))*(1-smooth)))))

# linewidths = list(1*np.array(list(nx.get_edge_attributes(G, 'weight').values())))
linewidths = mx.cNorm(mx.renormalize(list(1*np.array(list(nx.get_edge_attributes(G, 'weight').values())))),5)*10
node_weights = dict(zip(G.nodes(), rsc[t].tolist()))
nx.set_node_attributes(G, node_weights, "weight")
cmap = plt.cm.get_cmap("cool_r")

#forces = np.array([sum([data['weight'] for _, _, data in G.edges(node, data=True)]) for node in G.nodes])

# node_colors = {node: cmap(weight) for node, weight in node_weights.items()}
colors = list(zip(
mx.cNorm(mx.renormalize(pred[t].mean(0)),5),
mx.cNorm(mx.renormalize(mutu[t].mean(0)),5),
mx.cNorm(mx.renormalize(comp[t].mean(0)),5)
))

nx.draw_networkx(G, ax=ax, pos=pos, 
                  width=linewidths, 
                 edge_color=linewidths, 
                 edge_cmap=plt.cm.autumn_r, 
                 node_size= sim['D'][t], 
                 # node_color=list(node_colors.values())) #node_size= force ?
                 node_color=colors)

# ---------------------------------------------------------------------

ax.set_title('t = {}'.format(t))
plt.show()

#%%
switch_backend('module://matplotlib_inline.backend_inline')
import matplotlib.animation as animation
from mpl_toolkits.axes_grid1 import make_axes_locatable


fps=40
nseconds=10

nframes = fps*nseconds
# nframes = 30

# azims = np.linspace(0,360,nframes+1)[:-1] # full 360deg rotation
azims = np.append(np.linspace(-90,-1,int(nframes/2)+1)[:-1], np.linspace(-1,-90,round(nframes/2)+1)[:-1])


R = np.array([list(gamma['nodes']['power_pred']  [i].values()) for i in range(len(simulations))]).flatten()
G = np.array([list(gamma['nodes']['power_mutu']  [i].values()) for i in range(len(simulations))]).flatten()
B = np.array([list(gamma['nodes']['power_comp']  [i].values()) for i in range(len(simulations))]).flatten()

rgblist = np.array([
mx.cNorm(mx.renormalize(R),5)*255,
mx.cNorm(mx.renormalize(G),5)*255,
mx.cNorm(mx.renormalize(B),5)*255]).astype('int').T

colors = ['#%02x%02x%02x' % (r,g,b) for r,g,b in rgblist]

fig = plt.figure(figsize=(12,9)); ax = fig.add_subplot(111, projection='3d')

# plt.colorbar(scatter1,ax=ax, label='spectral radius variation')

def frame(t):
    print(np.round(t/nframes,3))
    global azims
    ax.clear()
    scatter1=ax.scatter((np.repeat(d,N)),
                        [list(gamma['nodes']['qdeg']   [i].values()) for i in range(len(simulations))],
                        [list(gamma['nodes']['popsizes'][i].values()) for i in range(len(simulations))],
                        c=colors, s=15)
    
    ax.set_xlabel(r"d", fontsize=16)
    ax.set_ylabel(r"strength")
    ax.set_zlabel(r"equilibrium population size")
    # ax.view_init(elev=30., azim=azims[t])
    ax.view_init(elev=15., azim=azims[t])
    ax.set_title('azimuth = {}°'.format(int(round(azims[t]))))

    
    # plt.show()
    return ax


timecode = str(time.time())
pattern = r'SIMULATIONS_(.*?_.*?)_'
easyname = re.search(pattern, filename).group(1)

gifname = 'scatter_' + easyname + '_' + '_' + timecode
ani = animation.FuncAnimation(fig, frame, frames=nframes, interval=1000/fps, blit=False)
ani.save(img_path / str('gif/' + gifname +'.gif'))



#%% 
t=-1
plt.imshow(gammas[t]*payoffs[t],norm=matplotlib.colors.TwoSlopeNorm(vmin=-.02, vcenter=0, vmax=.02),cmap='bwr')
plt.show()
#%% ANIMATE COMPLETE 1
smooth=0.85
simID=9 # 160 167 158 155 146 59 121

switch_backend('module://matplotlib_inline.backend_inline')


adjs  , mutu  , comp  , pred  , gammas   = evo.getADJs(simulations, simID=simID,return_gammas=True)
sim = simulations[simID]
G=nx.from_numpy_array(gammas[0])
pos=nx.layout.fruchterman_reingold_layout(G, weight='weight',threshold=1e-8,iterations=20) # threshold=1e-10,iterations=10


fig = plt.figure(figsize=(16,16)); 
ax1 = fig.add_subplot(221)
ax2 = fig.add_subplot(222)
ax3 = fig.add_subplot(212)
div = make_axes_locatable(ax)
x = np.arange(sim['v'].shape[2])
def frame(t):
    print(t)
    global pos
    ax1.clear()
    ax2.clear()
    ax3.clear()
    colors = np.array(list(zip(
    mx.cNorm(mx.renormalize(pred[t].mean(0)),5),
    mx.cNorm(mx.renormalize(mutu[t].mean(0)),5),
    mx.cNorm(mx.renormalize(comp[t].mean(0)),5)
    )))
    

    ax1.imshow(gammas[t]*payoffs[simID],norm=matplotlib.colors.TwoSlopeNorm(vmin=-.01, vcenter=0, vmax=.01),cmap='bwr')
    
    G=nx.from_numpy_array(gammas[t])
    pos_new=nx.layout.fruchterman_reingold_layout(G, weight='weight', pos=pos,threshold=1e-8,iterations=20) # threshold=1e-10,iterations=10
    pos = dict(zip(G.nodes(), list((np.array(list(pos.values()))*smooth + np.array(list(pos_new.values()))*(1-smooth)))))

    linewidths =          mx.renormalize(list(1*np.array(list(nx.get_edge_attributes(G, 'weight').values()))))*2

    nx.draw_networkx(G,ax=ax2, pos=pos, 
                     width=linewidths, 
                     edge_color=linewidths, 
                     node_color=colors,
                     edge_cmap=plt.cm.autumn_r,
                     node_size= sim['D'][t])
    
    # ax3.plot(sim['v'][t].T)
    hexcolors = ['#%02x%02x%02x' % (r,g,b) for r,g,b in (colors*255).astype(int)]
    
    for i__N in range(N):
        ax3.plot(x, sim['v'][t,i__N], c= hexcolors[i__N])
    return ax1,ax2,ax3


timecode = str(time.time())
pattern = r'SIMULATIONS_(.*?_.*?)_'
easyname = re.search(pattern, filename).group(1)

gifname = 'full_' + easyname + '_' + str(simID) + '_' + timecode
ani = animation.FuncAnimation(fig, frame, frames=len(gammas)-1, interval=20, blit=False) # frames=len(adjs)
ani.save(img_path / str('gif/' + gifname +'.gif'))



#%%
fig = plt.figure(figsize=(16,12)); ax3 = fig.add_subplot(111)
hexcolors = ['#%02x%02x%02x' % (r,g,b) for r,g,b in (colors*255).astype(int)]

for i__N in range(N):
    ax3.plot(x, sim['v'][t,i__N], c= hexcolors[i__N])
    
plt.show()